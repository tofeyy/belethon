"""

âƒ `{i}Ø³` Ø£Ùˆ `{i}Ø³Ù…Ø§Ø­`
    ÙŠØ³ØªØ®Ø¯Ù… Ø¨Ø£Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¨ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ùˆ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡
    Ù„Ù€ Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙˆØ£ÙŠÙ‚Ø§Ù Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ù…Ø¹Ù‡

âƒ `{i}Ø±` Ø£Ùˆ `{i}Ø±ÙØ¶`
    ÙŠØ³ØªØ®Ø¯Ù… Ø¨Ø£Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¨ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ùˆ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡
    Ù„Ù€ Ø±ÙØ¶ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙˆØ£Ø±Ø¬Ø§Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø´ØºØ§Ù„ Ù…Ø¹Ù‡

âƒ `{i}Ø¨Ù„ÙˆÙƒ`
    Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: Ø¨Ø£Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¨ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ùˆ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡
    Ø§Ù„Ø´Ø±Ø­: Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Øµ


âƒ `{i}Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ù„ÙˆÙƒ` | `{i}Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ù„ÙˆÙƒ Ù„Ù„ÙƒÙ„`
    ÙŠØ³ØªØ®Ø¯Ù… Ù‡Ø°Ø§ Ø¨Ø£Ø±Ø³Ø§Ù„Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„Ø®Ø§ØµØ©
    Ù„Ù€ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø®Ø§ØµØ© ÙˆØ§Ø°Ø§ ÙƒØªØ¨Øª Ù…Ø¹ Ø§Ù„Ø§Ù…Ø± Ù„Ù„ÙƒÙ„ Ø³ÙŠÙ„ØºÙŠ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†


âƒ `{i}ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§Ø±Ø´ÙØ©`
    Ù„Ù€ Ø£Ø±Ø´ÙØ© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©

âƒ `{i}Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø±Ø´ÙØ©`
    Ù„Ù€ Ø£ÙŠÙ‚Ø§Ù Ø£Ø±Ø´ÙØ© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©

âƒ `{i}Ù…Ø³Ø­ Ø§Ù„Ø§Ø±Ø´ÙØ©`
    Ù„Ù€ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù…Ø¤Ø±Ø´ÙØ©

âƒ `{i}Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³Ù…ÙˆØ­ÙŠÙ†`
   Ù„Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡Ù… Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ

âŒ”âˆ® Ù‡Ø°Ù‡ Ø§Ù„Ø§ÙˆØ§Ù…Ø± ØªØ¹Ù…Ù„ ÙÙ‚Ø· Ø­ÙŠÙ† ØªØ´ØºÙŠÙ„ Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø®Ø§Øµ
"""

import asyncio
import re
from os import remove

from resources import DEVLIST
from tabulate import tabulate
from belethon import HNDLR
from telethon import events
from telethon.errors import MessageNotModifiedError
from telethon.tl import types
from telethon.tl.custom import Button
from telethon.tl.functions.contacts import (BlockRequest, GetBlockedRequest,
                                            UnblockRequest)
from telethon.tl.functions.messages import ReportSpamRequest
from telethon.utils import get_display_name, resolve_bot_file_id

from database.core.settings import KeySettings

from .. import (LOGS, tgbot, callback, in_pattern, inline_mention,
               jmdB, jmubot, belethon_cmd)

OWNER_NAME = jmubot.full_name
OWNER_ID = jmubot.me.id

COUNT_PM = {}
LASTMSG = {}
WARN_MSGS = {}
U_WARNS = {}

if isinstance(jmdB.get_key("PMPERMIT"), (int, str)):
    value = [jmdB.get_key("PMPERMIT")]
    jmdB.set_key("PMPERMIT", value)

keym = KeySettings("PMPERMIT", cast=list)
PMPIC = jmdB.get_key("PMPIC")
LOG_CHAT = jmdB.get_key("LOG_CHAT")

UND = "**âƒ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø£Ù†ØªØ¸Ø§Ø±  Ø§Ù„Ø±Ø¯ Ù…Ù† Ù…Ø§Ù„Ùƒ Ø§Ù„Ø­Ø³Ø§Ø¨**\n**âƒ ÙˆØ¥Ù† ÙƒØ±Ø±Øª Ø£Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø³ÙˆÙ ÙŠØªÙ… Ø­Ø¸Ø±Ùƒ**"
UNS = "**âŒ”âˆ®  Ù„Ù€Ù‚Ø¯ Ø£Ø®Ø¨Ø±ØªÙƒ Ø£Ù† Ù„Ø§ ØªÙÙ€ÙƒÙ€Ø±Ø± Ø£Ø±Ø³Ù€Ø§Ù„ Ø§Ù„Ø±Ø³Ù€Ø§Ø¦Ù„\nâƒ ÙŠØ¨Ù€Ø¯Ùˆ Ø£Ù†Ù€Ùƒ Ù„Ø§ ØªÙØ­Ù€Ø³Ù† Ø§Ù„Ù€Ù‚Ø±Ø§Ø¡Ø© Ø³ÙŠØªÙ… Ø­Ø¸Ù€Ø±Ùƒ  :)**" 
NO_REPLY = "**âŒ”âˆ® ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§ÙˆÙ„Ø§ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ù…Ø± ÙÙŠ Ø§Ù„Ø®Ø§Øµ**."


UNAPPROVED_MSG = "**Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ {ON}!**\n\n{UND}\n\nÙ„Ø¯ÙŠÙƒ {warn}/{twarn} ØªØ­Ø°ÙŠØ±Ø§Øª"
if jmdB.get_key("PM_TEXT"):
    UNAPPROVED_MSG = (
        "**Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ {ON}!**\n\n"
        + jmdB.get_key("PM_TEXT")
        + "\n\nÙ„Ø¯ÙŠÙƒ {warn}/{twarn} ØªØ­Ø°ÙŠØ±Ø§Øª"
    )

WARNS = jmdB.get_key("PMWARNS") or 4

_not_approved = {}
_to_delete = {}

my_bot = tgbot.me.username


def update_pm(userid, message, warns_given):
    try:
        WARN_MSGS.update({userid: message})
    except KeyError:
        pass
    try:
        U_WARNS.update({userid: warns_given})
    except KeyError:
        pass


async def delete_pm_warn_msgs(chat: int):
    try:
        await _to_delete[chat].delete()
    except KeyError:
        pass


# =================================================================


if jmdB.get_key("PMSETTING"):
    if jmdB.get_key("AUTOAPPROVE"):

        @jmubot.on(
            events.NewMessage(
                outgoing=True,
                func=lambda e: e.is_private and e.out and not e.text.startswith(HNDLR),
            ),
        )
        async def autoappr(e):
            miss = await e.get_chat()
            if miss.bot or miss.is_self or miss.verified or miss.id in DEVLIST:
                return
            if keym.contains(miss.id):
                return
            keym.add(miss.id)
            await delete_pm_warn_msgs(miss.id)
            try:
                await jmubot.edit_folder(miss.id, folder=0)
            except BaseException:
                pass
            try:
                await tgbot.edit_message(
                    LOG_CHAT,
                    _not_approved[miss.id],
                    f"#Ø§Ù„Ø³Ù…Ø§Ø­_ØªÙ„Ù‚Ø§Ø¦ÙŠØ§ : <b>Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø©.\nØ§Ù„Ù…Ø³ØªØ®Ø¯Ù… : {inline_mention(miss, html=True)}</b> [<code>{miss.id}</code>]",
                    parse_mode="html",
                )
            except KeyError:
                await tgbot.send_message(
                    LOG_CHAT,
                    f"#Ø§Ù„Ø³Ù…Ø§Ø­_ØªÙ„Ù‚Ø§Ø¦ÙŠØ§ : <b>Ø§Ù„Ù€Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø©.\nØ§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© : {inline_mention(miss, html=True)}</b> [<code>{miss.id}</code>]",
                    parse_mode="html",
                )
            except MessageNotModifiedError:
                pass

    @jmubot.on(
        events.NewMessage(
            incoming=True,
            func=lambda e: e.is_private
            and e.sender_id not in DEVLIST
            and not e.out
            #       and not e.sender.bot
            #      and not e.sender.is_self
            #       and not e.sender.verified,
        )
    )
    async def permitpm(event):
        sender = await event.get_sender()
        if (sender.bot or sender.verified or sender.is_self):
            return
        inline_pm = jmdB.get_key("INLINE_PM") or False
        user = event.sender
        if not keym.contains(user.id) and event.text != UND:
            if jmdB.get_key("MOVE_ARCHIVE"):
                try:
                    await jmubot.edit_folder(user.id, folder=1)
                except BaseException as er:
                    LOGS.info(er)
            if event.media and not jmdB.get_key("DISABLE_PMDEL"):
                await event.delete()
            name = user.first_name
            fullname = get_display_name(user)
            username = f"@{user.username}"
            mention = inline_mention(user)
            count = keym.count()
            try:
                wrn = COUNT_PM[user.id] + 1
                await tgbot.edit_message(
                    jmdB.get_key("LOG_CHAT"),
                    _not_approved[user.id],
                    f"Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø®Ø§Øµ Ù…Ù† Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† \nØ§Ù„Ù…Ø³ØªØ®Ø¯Ù…: **{mention}** [`{user.id}`] Ù…Ø¹ **{wrn}/{WARNS}** Ù…Ù† Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª",
                    buttons=[
                        Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                )
            except KeyError:
                _not_approved[user.id] = await tgbot.send_message(
                    jmdB.get_key("LOG_CHAT"),
                    f"Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø®Ø§Øµ Ù…Ù† Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† \nØ§Ù„Ù…Ø³ØªØ®Ø¯Ù…: **{mention}** [`{user.id}`] Ù…Ø¹ **1/{WARNS}** Ù…Ù† Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª",
                    buttons=[
                        Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                )
                wrn = 1
            except MessageNotModifiedError:
                wrn = 1
            if user.id in LASTMSG:
                prevmsg = LASTMSG[user.id]
                if event.text != prevmsg:
                    if "Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ†" in event.text or "**Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ†" in event.text:
                        return
                    await delete_pm_warn_msgs(user.id)
                    message_ = UNAPPROVED_MSG.format(
                        ON=OWNER_NAME,
                        warn=wrn,
                        twarn=WARNS,
                        UND=UND,
                        name=name,
                        fullname=fullname,
                        username=username,
                        count=count,
                        mention=mention,
                    )
                    update_pm(user.id, message_, wrn)
                    if inline_pm:
                        results = await jmubot.inline_query(
                            my_bot, f"ip_{user.id}"
                        )
                        try:
                            _to_delete[user.id] = await results[0].click(
                                user.id, reply_to=event.id, hide_via=True
                            )
                        except Exception as e:
                            LOGS.info(str(e))
                    elif PMPIC:
                        _to_delete[user.id] = await jmubot.send_file(
                            user.id,
                            PMPIC,
                            caption=message_,
                        )
                    else:
                        _to_delete[user.id] = await jmubot.send_message(
                            user.id, message_
                        )

                else:
                    await delete_pm_warn_msgs(user.id)
                    message_ = UNAPPROVED_MSG.format(
                        ON=OWNER_NAME,
                        warn=wrn,
                        twarn=WARNS,
                        UND=UND,
                        name=name,
                        fullname=fullname,
                        username=username,
                        count=count,
                        mention=mention,
                    )
                    update_pm(user.id, message_, wrn)
                    if inline_pm:
                        try:
                            results = await jmubot.inline_query(
                                my_bot, f"ip_{user.id}"
                            )
                            _to_delete[user.id] = await results[0].click(
                                user.id, reply_to=event.id, hide_via=True
                            )
                        except Exception as e:
                            LOGS.info(str(e))
                    elif PMPIC:
                        _to_delete[user.id] = await jmubot.send_file(
                            user.id,
                            PMPIC,
                            caption=message_,
                        )
                    else:
                        _to_delete[user.id] = await jmubot.send_message(
                            user.id, message_
                        )
                LASTMSG.update({user.id: event.text})
            else:
                await delete_pm_warn_msgs(user.id)
                message_ = UNAPPROVED_MSG.format(
                    ON=OWNER_NAME,
                    warn=wrn,
                    twarn=WARNS,
                    UND=UND,
                    name=name,
                    fullname=fullname,
                    username=username,
                    count=count,
                    mention=mention,
                )
                update_pm(user.id, message_, wrn)
                if inline_pm:
                    try:
                        results = await jmubot.inline_query(
                            my_bot, f"ip_{user.id}"
                        )
                        _to_delete[user.id] = await results[0].click(
                            user.id, reply_to=event.id, hide_via=True
                        )
                    except Exception as e:
                        LOGS.info(str(e))
                elif PMPIC:
                    _to_delete[user.id] = await jmubot.send_file(
                        user.id,
                        PMPIC,
                        caption=message_,
                    )
                else:
                    _to_delete[user.id] = await jmubot.send_message(
                        user.id, message_
                    )
            LASTMSG.update({user.id: event.text})
            if user.id not in COUNT_PM:
                COUNT_PM.update({user.id: 1})
            else:
                COUNT_PM[user.id] = COUNT_PM[user.id] + 1
            if COUNT_PM[user.id] >= WARNS:
                await delete_pm_warn_msgs(user.id)
                _to_delete[user.id] = await event.respond(UNS)
                try:
                    del COUNT_PM[user.id]
                    del LASTMSG[user.id]
                except KeyError:
                    await tgbot.send_message(
                        jmdB.get_key("LOG_CHAT"),
                        "**Ù‡Ù†Ø§Ù„Ùƒ Ø®Ø·Ø£ ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙˆØ±Ø³ Ø¹Ø¨Ø±  `.Ø§Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„`",
                    )
                    return LOGS.info("Ù‡Ù†Ø§Ù„Ùƒ Ø®Ø·Ø£ ÙÙŠ Ù…ØªØºÙŠØ± COUNT_PM")
                await jmubot(BlockRequest(user.id))
                await jmubot(ReportSpamRequest(peer=user.id))
                await tgbot.edit_message(
                    jmdB.get_key("LOG_CHAT"),
                    _not_approved[user.id],
                    f"**âœ¦ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {mention}** [`{user.id}`]\nâœ¦ ØªÙ… Ø­Ø¸Ø±Ù‡ Ø¨Ø³Ø¨Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø± ÙÙŠ Ø§Ù„Ø®Ø§Øµ.",
                )

    @belethon_cmd(pattern="(ØªØ´ØºÙŠÙ„|Ø§ÙŠÙ‚Ø§Ù|Ù…Ø³Ø­) Ø§Ù„Ø§Ø±Ø´ÙØ©$", fullsudo=True)
    async def _(e):
        x = e.pattern_match.group(1).strip()
        if x == "ØªØ´ØºÙŠÙ„":
            jmdB.set_key("MOVE_ARCHIVE", "True")
            await e.eor("**- Ù…Ù† Ø§Ù„Ø£Ù† Ø³ÙŠØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡ Ø§Ù„Ù‰ Ø§Ù„Ø§Ø±Ø´ÙŠÙ**", time=5)
        elif x == "Ø§ÙŠÙ‚Ø§Ù":
            jmdB.set_key("MOVE_ARCHIVE", "False")
            await e.eor("**- Ù…Ù† Ø§Ù„Ø£Ù† Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆÙ‚Ù Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡ Ø§Ù„Ù‰ Ø§Ù„Ø§Ø±Ø´ÙŠÙ**", time=5)
        elif x == "Ù…Ø³Ø­":
            try:
                await e.client.edit_folder(unpack=1)
                await e.eor("**âœ¦ ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ø±Ø´ÙŠÙ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø¨Ù†Ø¬Ø§Ø­ âœ“**", time=5)
            except Exception as mm:
                await e.eor(str(mm), time=5)

    @belethon_cmd(pattern="(Ø³|Ø³Ù…Ø§Ø­)(?: |$)", fullsudo=True)
    async def approvepm(apprvpm):
        if apprvpm.reply_to_msg_id:
            user = (await apprvpm.get_reply_message()).sender
        elif apprvpm.is_private:
            user = await apprvpm.get_chat()
        else:
            return await apprvpm.edit(NO_REPLY)
        if user.id in DEVLIST:
            return await apprvpm.eor(
                "**âŒ”âˆ® Ù‡Ø°Ø§ Ù‡Ùˆ Ù…Ø·ÙˆØ± Ø³ÙˆØ±Ø³ Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ù‡Ùˆ Ø¨Ø§Ù„Ø£ØµÙ„ Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©  !**",
            )
        if not keym.contains(user.id):
            keym.add(user.id)
            try:
                await delete_pm_warn_msgs(user.id)
                await apprvpm.client.edit_folder(user.id, folder=0)
            except BaseException:
                pass
            await apprvpm.eor(
                f"<b>{inline_mention(user, html=True)}</b> <code>ØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
                parse_mode="html",
            )
            try:
                await tgbot.edit_message(
                    jmdB.get_key("LOG_CHAT"),
                    _not_approved[user.id],
                    f"#Ø§Ù„Ø³Ù…Ø§Ø­\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>Ù„Ù‚Ø¯ ØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
                    buttons=[
                        Button.inline(
                            "Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"disapprove_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                    parse_mode="html",
                )
            except KeyError:
                _not_approved[user.id] = await tgbot.send_message(
                    jmdB.get_key("LOG_CHAT"),
                    f"#Ø§Ù„Ø³Ù…Ø§Ø­\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>Ù„Ù‚Ø¯ ØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
                    buttons=[
                        Button.inline(
                            "Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"disapprove_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                    parse_mode="html",
                )
            except MessageNotModifiedError:
                pass
        else:
            await apprvpm.eor("**âŒ”âˆ® Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø£ØµÙ„Ø§**", time=5)

    @belethon_cmd(pattern="(Ø±|Ø±ÙØ¶)(?: |$)", fullsudo=True)
    async def disapprovepm(e):
        if e.reply_to_msg_id:
            user = (await e.get_reply_message()).sender
        elif e.is_private:
            user = await e.get_chat()
        else:
            return await e.edit(NO_REPLY)
        if user.id in DEVLIST:
            return await e.eor(
                "**âŒ”âˆ® Ø§Ù†Ø¬Ø¨ Ù„Ùƒ Ù‡Ø°Ø§ Ù…Ø·ÙˆØ± Ø§Ù„Ø³ÙˆØ±Ø³**\nÙ„Ø§ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø±ÙØ¶Ù‡ Ø£Ø¨Ø¯Ø§  ':) ",
            )
        if keym.contains(user.id):
            keym.remove(user.id)
            await e.eor(
                f"<b>{inline_mention(user, html=True)}</b> <code>ØªÙ… Ø±ÙØ¶Ù‡ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
                parse_mode="html",
            )
            try:
                await tgbot.edit_message(
                    jmdB.get_key("LOG_CHAT"),
                    _not_approved[user.id],
                    f"#Ø§Ù„Ø±ÙØ¶\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>Ù„Ù‚Ø¯ ØªÙ… Ø±ÙØ¶Ù‡ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ.</code>",
                    buttons=[
                        Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                    parse_mode="html",
                )
            except KeyError:
                _not_approved[user.id] = await tgbot.send_message(
                    jmdB.get_key("LOG_CHAT"),
                    f"#Ø§Ù„Ø±ÙØ¶\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>Ù„Ù‚Ø¯ ØªÙ… Ø±ÙØ¶Ù‡ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ.</code>",
                    buttons=[
                        Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{user.id}"),
                        Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user.id}"),
                    ],
                    parse_mode="html",
                )
            except MessageNotModifiedError:
                pass
        else:
            await e.eor(
                f"<b>{inline_mention(user, html=True)}</b> <code>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø±ÙÙˆØ¶ Ø¨Ø§Ù„Ø£ØµÙ„</code>",
                parse_mode="html",
            )


@belethon_cmd(pattern="Ø¨Ù„ÙˆÙƒ( (.*)|$)", fullsudo=True)
async def blockpm(block):
    match = block.pattern_match.group(1).strip()
    if block.reply_to_msg_id:
        user = (await block.get_reply_message()).sender_id
    elif match:
        try:
            user = await block.client.parse_id(match)
        except Exception as er:
            return await block.eor(str(er))
    elif block.is_private:
        user = block.chat_id
    else:
        return await block.eor(NO_REPLY, time=10)

    await block.client(BlockRequest(user))
    aname = await block.client.get_entity(user)
    await block.eor(f"**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {inline_mention(aname)}** [`{user}`]\n**âƒ ØªÙ… Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ ÙÙŠ Ø§Ù„Ø®Ø§Øµ**")
    try:
        keym.remove(user)
    except AttributeError:
        pass
    try:
        await tgbot.edit_message(
            jmdB.get_key("LOG_CHAT"),
            _not_approved[user],
            f"#Ø¨Ù„ÙˆÙƒ\n\n**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {inline_mention(aname)}** [`{user}`]\n**âƒ  ØªÙ… Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**",
            buttons=[
                Button.inline("Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ù„ÙˆÙƒ", data=f"unblock_{user}"),
            ],
        )
    except KeyError:
        _not_approved[user] = await tgbot.send_message(
            jmdB.get_key("LOG_CHAT"),
            f"#Ø¨Ù„ÙˆÙƒ\n\n**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {inline_mention(aname)}** [`{user}`]\n**âƒ ØªÙ… Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**",
            buttons=[
                Button.inline("Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ù„ÙˆÙƒ", data=f"unblock_{user}"),
            ],
        )
    except MessageNotModifiedError:
        pass


@belethon_cmd(pattern="Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¨Ù„ÙˆÙƒ( (.*)|$)", fullsudo=True)
async def unblockpm(event):
    match = event.pattern_match.group(1).strip()
    reply = await event.get_reply_message()
    if reply:
        user = reply.sender_id
    elif match:
        if match == "Ù„Ù„ÙƒÙ„":
            msg = await event.eor("**âŒ”âˆ® Ø¬Ù€Ø§Ø±Ù Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø®Ø§Øµ**")
            u_s = await event.client(GetBlockedRequest(0, 0))
            count = len(u_s.users)
            if not count:
                return await msg.eor("**âŒ”âˆ® Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ† Ù„Ø±ÙØ¹ Ø§Ù„Ø­Ø¸Ø± Ù…Ù†Ù‡Ù… Ø£ØµÙ„Ø§**")
            for user in u_s.users:
                await asyncio.sleep(1)
                await event.client(UnblockRequest(user.id))
            # GetBlockedRequest return 20 users at most.
            if count < 20:
                return await msg.eor(f"**âŒ”âˆ® ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± {count} Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø®Ø§Øµ**")
            while u_s.users:
                u_s = await event.client(GetBlockedRequest(0, 0))
                for user in u_s.users:
                    await asyncio.sleep(3)
                    await event.client(UnblockRequest(user.id))
                count += len(u_s.users)
            return await msg.eor(f"**âŒ”âˆ® ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø± {count} Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø®Ø§Øµ**")

        try:
            user = await event.client.parse_id(match)
        except Exception as er:
            return await event.eor(str(er))
    elif event.is_private:
        user = event.chat_id
    else:
        return await event.eor(NO_REPLY, time=10)
    try:
        await event.client(UnblockRequest(user))
        aname = await event.client.get_entity(user)
        await event.eor(f"**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:{inline_mention(aname)}** [`{user}`]\n**âƒ ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**")
    except Exception as et:
        return await event.eor(f"ERROR - {et}")
    try:
        await tgbot.edit_message(
            jmdB.get_key("LOG_CHAT"),
            _not_approved[user],
            f"#Ø§Ù„ØºØ§Ø¡_Ø§Ù„Ø¨Ù„ÙˆÙƒ\n\n**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {inline_mention(aname)}** [`{user}`]\n**âƒ Ù„Ù‚Ø¯ ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**",
            buttons=[
                Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user}"),
            ],
        )
    except KeyError:
        _not_approved[user] = await tgbot.send_message(
            jmdB.get_key("LOG_CHAT"),
            f"#Ø§Ù„ØºØ§Ø¡_Ø§Ù„Ø¨Ù„ÙˆÙƒ\n\n**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {inline_mention(aname)}** [`{user}`]\n**âƒ Ù„Ù‚Ø¯ ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**",
            buttons=[
                Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{user}"),
            ],
        )
    except MessageNotModifiedError:
        pass


@belethon_cmd(pattern="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³Ù…ÙˆØ­ÙŠÙ†$", owner=True)
async def list_approved(event):
    xx = await event.eor("**âŒ”âˆ® Ø¬Ù€Ø§Ø±Ù Ø¬Ù„Ø¨ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø£Ù†ØªØ¸Ø§Ø±**")
    all = keym.get()
    if not all:
        return await xx.eor("**âŒ”âˆ® Ø£Ù†Øª Ù„Ù… ØªØ³Ù…Ø­ Ù„Ø£ÙŠ Ø´Ø®Øµ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ Ø§ØµÙ„Ø§**", time=5)
    users = []
    for i in all:
        try:
            name = get_display_name(await jmubot.get_entity(i))
        except BaseException:
            name = ""
        users.append([name.strip(), str(i)])
    with open("Ø§Ù„Ù…Ø³Ù…ÙˆØ­ÙŠÙ†.txt", "w") as list_appr:
        if tabulate:
            list_appr.write(
                tabulate(
                    users,
                    headers=[
                        "Ø§Ù„Ù€Ù…Ø¹Ù€Ø±Ù",
                        "Ø§Ù„Ø£ÙŠÙ€Ø¯ÙŠ"],
                    showindex="always")
            )
        else:
            text = "".join(f"[{user[-1]}] - {user[0]}" for user in users)
            list_appr.write(text)
    await event.reply(
        f"**âŒ”âˆ® Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡Ù… Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹ [{OWNER_NAME}](tg://user?id={OWNER_ID})**",
        file="Ø§Ù„Ù…Ø³Ù…ÙˆØ­ÙŠÙ†.txt",
    )

    await xx.delete()
    remove("Ø§Ù„Ù…Ø³Ù…ÙˆØ­ÙŠÙ†.txt")


@callback(
    re.compile(
        b"approve_(.*)",
    ),
    from_users=[jmubot.uid],
)
async def apr_in(event):
    uid = int(event.data_match.group(1).decode("UTF-8"))
    if uid in DEVLIST:
        await event.edit("**âŒ”âˆ® ÙŠØ§Ø¨ÙˆÙŠØ© Ù‡Ø°Ø§ Ù…Ø·ÙˆØ± Ø§Ù„Ø³ÙˆØ±Ø³ ØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© ÙÙˆØ±Ø§**")
    if not keym.contains(uid):
        keym.add(uid)
        try:
            await jmubot.edit_folder(uid, folder=0)
        except BaseException:
            pass
        try:
            user = await jmubot.get_entity(uid)
        except BaseException:
            return await event.delete()
        await event.edit(
            f"#Ø§Ù„Ø³Ù…Ø§Ø­\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>ØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
            buttons=[
                [
                    Button.inline("Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"disapprove_{uid}"),
                    Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{uid}"),
                ],
            ],
            parse_mode="html",
        )
        await delete_pm_warn_msgs(uid)
        await event.answer("**âŒ”âˆ® ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ**", alert=True)
    else:
        await event.edit(
            "**âŒ”âˆ® Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø£ØµÙ„Ø§**",
            buttons=[
                [
                    Button.inline("Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"disapprove_{uid}"),
                    Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{uid}"),
                ],
            ],
        )


@callback(
    re.compile(
        b"disapprove_(.*)",
    ),
    from_users=[jmubot.uid],
)
async def disapr_in(event):
    uid = int(event.data_match.group(1).decode("UTF-8"))
    if keym.contains(uid):
        keym.remove(uid)
        try:
            user = await jmubot.get_entity(uid)
        except BaseException:
            return await event.delete()
        await event.edit(
            f"#Ø±ÙØ¶\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>ØªÙ… Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ù…Ø¹Ùƒ</code>",
            buttons=[
                [
                    Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{uid}"),
                    Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{uid}"),
                ],
            ],
            parse_mode="html",
        )
        await event.answer("**âŒ”âˆ® ØªÙ… Ø¨Ù†Ø¬Ø§Ø­ Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© âœ“**", alert=True)
    else:
        await event.edit(
            "**âŒ”âˆ® Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù‡ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø£ØµÙ„Ø§**",
            buttons=[
                [
                    Button.inline("Ø±ÙØ¶ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"disapprove_{uid}"),
                    Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{uid}"),
                ],
            ],
        )


@callback(
    re.compile(
        b"block_(.*)",
    ),
    from_users=[jmubot.uid],
)
async def blck_in(event):
    uid = int(event.data_match.group(1).decode("UTF-8"))
    try:
        await jmubot(BlockRequest(uid))
    except BaseException:
        pass
    try:
        user = await jmubot.get_entity(uid)
    except BaseException:
        return await event.delete()
    await event.edit(
        f"#Ø¨Ù„ÙˆÙƒ\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø®Ø§Øµ</code>",
        buttons=Button.inline("Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø±", data=f"unblock_{uid}"),
        parse_mode="html",
    )
    await event.answer("ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­ âœ“", alert=True)


@callback(
    re.compile(
        b"unblock_(.*)",
    ),
    from_users=[jmubot.uid],
)
async def unblck_in(event):
    uid = int(event.data_match.group(1).decode("UTF-8"))
    try:
        await jmubot(UnblockRequest(uid))
    except BaseException:
        pass
    try:
        user = await jmubot.get_entity(uid)
    except BaseException:
        return await event.delete()
    await event.edit(
        f"#Ø§Ù„ØºØ§Ø¡_Ø­Ø¸Ø±\n\n<b>{inline_mention(user, html=True)}</b> [<code>{user.id}</code>] <code>ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø­Ø¸Ø±Ù‡ Ù…Ù† Ø§Ù„Ø®Ø§Øµ</code>",
        buttons=Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{uid}"),
        parse_mode="html",
    )
    await event.answer("Unblocked.", alert=True)


@in_pattern(re.compile("ip_(.*)"), owner=True)
async def in_pm_ans(event):
    from_user = int(event.pattern_match.group(1).strip())
    try:
        warns = U_WARNS[from_user]
    except Exception as e:
        LOGS.info(e)
        warns = "?"
    try:
        msg_ = WARN_MSGS[from_user]
    except KeyError:
        msg_ = "**âŒ”âˆ® Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ {OWNER_NAME}**"
    wrns = f"{warns}/{WARNS}"
    buttons = [
        [
            Button.inline("ÙƒØ´Ù", data=f"admin_only{from_user}"),
            Button.inline(wrns, data=f"don_{wrns}"),
        ]
    ]
    include_media = True
    mime_type, res = None, None
    cont = None
    try:
        ext = PMPIC.split(".")[-1].lower()
    except (AttributeError, IndexError):
        ext = None
    if ext in ["img", "jpg", "png"]:
        type = "photo"
        mime_type = "image/jpg"
    elif ext in ["mp4", "mkv", "gif"]:
        mime_type = "video/mp4"
        type = "gif"
    else:
        try:
            res = resolve_bot_file_id(PMPIC)
        except ValueError:
            pass
        if res:
            res = [
                await event.builder.document(
                    res,
                    title="Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ø§Ù„Ø£Ù†Ù„Ø§ÙŠÙ†",
                    description="~ @Source_b",
                    text=msg_,
                    buttons=buttons,
                    link_preview=False,
                )
            ]
        else:
            type = "article"
            include_media = False
    if not res:
        if include_media:
            cont = types.InputWebDocument(PMPIC, 0, mime_type, [])
        res = [
            event.builder.article(
                title="Ù†Ø¸Ø§Ù… Ø­Ù…Ø§ÙŠØ© Ø¨ÙŠÙ„ÙŠØ«ÙˆÙ† Ø§Ù„Ø£Ù†Ù„Ø§ÙŠÙ†",
                type=type,
                text=msg_,
                description="~ @Source_b",
                include_media=include_media,
                buttons=buttons,
                thumb=cont,
                content=cont,
            )
        ]
    await event.answer(res, switch_pm="â€¢ belethon â€¢", switch_pm_param="start")


@callback(re.compile("admin_only(.*)"), from_users=[jmubot.uid])
async def _admin_tools(event):
    chat = int(event.pattern_match.group(1).strip())
    await event.edit(
        buttons=[
            [
                Button.inline("Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¯Ø±Ø¯Ø´Ø©", data=f"approve_{chat}"),
                Button.inline("Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", data=f"block_{chat}"),
            ],
            [Button.inline("Â« Ø±Ø¬ÙˆØ¹", data=f"pmbk_{chat}")],
        ],
    )


@callback(re.compile("don_(.*)"))
async def _mejik(e):
    data = e.pattern_match.group(1).strip().decode("utf-8").split("/")
    text = "ğŸ‘®â€â™‚ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª : " + data[0]
    text += "\nğŸ¤– Ø¹Ø¯Ø¯ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª Ø§Ù„ÙƒÙÙ„ÙŠ : " + data[1]
    await e.answer(text, alert=True)


@callback(re.compile("pmbk_(.*)"))
async def edt(event):
    from_user = int(event.pattern_match.group(1).strip())
    try:
        warns = U_WARNS[from_user]
    except Exception as e:
        LOGS.info(str(e))
        warns = "0"
    wrns = f"{warns}/{WARNS}"
    await event.edit(
        buttons=[
            [
                Button.inline("Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª", data=f"admin_only{from_user}"),
                Button.inline(wrns, data=f"don_{wrns}"),
            ]
        ],
        )
